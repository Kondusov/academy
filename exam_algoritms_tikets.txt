1. Сортировка выбором
Задача 1: Напишите функцию, которая принимает массив целых чисел и сортирует его с помощью алгоритма сортировки выбором (от меньшего к большему). Например, для входного массива [12,5,3,8] результат должен быть [3,5,8,12].
Задача 2: Реализуйте сортировку выбором для массива строк. Строки должны быть отсортированы по длине (от меньшего к большему). Например, для входного массива ["banana", "apple", "kiwi"] результат должен быть ["kiwi", "apple", "banana"].

2. Массивы и связанные списки
Задача 1: Создайте класс для списка и реализуйте методы для добавления элемента в конец списка, удаления элемента(находим по значению), и поиска элемента по значению. Дополнительно добавьте метод, который возвращает количество элементов в списке, и метод - который печатает весь список в консоль или на экран.
Задача 2: Напишите функцию, которая принимает массив чисел и возвращает связанный список, содержащий те же числа, а также добавьте метод, который находит среднее значение всех 
элементов списка.

3. Рекурсия
Задача 1: Напишите рекурсивную функцию, которая вычисляет ( n )-й член последовательности Фибоначчи. Например, для n = 5 результат должен быть 5.
Задача 2: Реализуйте рекурсивную функцию для вычисления суммы всех элементов массива, но добавьте условие, что если элемент отрицательный, он не учитывается в сумме. Например, для 
входного массива [1, -2, 3, 4] результат должен быть 8.

4. Стек
Задача 1: Реализуйте стек с операциями добавления элемента в стек и удаления элемента. Например, добавьте элементы 1, 2, 3 и удалите один элемент.
Задача 2: Напишите программу, которая проверяет, является ли строка с круглой скобкой сбалансированной. Усложните задачу, добавив поддержку квадратных и фигурных скобок. Например, 
строка "{[()()]}" должна вернуть true, а "{[(])}" — false.

5. Структура данных "очередь"
Реализуйте структуру данных "очередь". Напишите программу, содержащую описание очереди и моделирующую работу очереди, реализовав все указанные здесь методы. Программа считывает последовательность команд и в зависимости от команды выполняет ту или иную операцию. После выполнения каждой команды программа должна вывести одну строчку.
Возможные команды для программы:
1. Добавить в очередь число n. Программа должна вывести ok - n.
2. Удалить из очереди первый элемент. Программа должна вывести его значение.
3. Программа должна вывести значение первого элемента, не удаляя его из очереди.
4. Программа должна вывести количество элементов в очереди.
5. Программа должна очистить очередь и вывести ok - clear.
6. Программа должна вывести bye и завершить работу.

6. Пузырьковая сортировка
Задача 1: Реализуйте пузырьковую сортировку для массива целых чисел. Например, для входного массива [5, 3, 8, 4, 2] результат должен быть [2, 3, 4, 5, 8].
Задача 2: Напишите функцию, которая сортирует массив строк в порядке убывания (по алфавиту). Например, для входного массива ["pear", "apple", "orange"] результат должен быть 
["pear", "orange", "apple"].

7. Бинарный поиск
Задача 1: Напишите функцию, которая выполняет бинарный поиск в отсортированном массиве (изначально дается неотсортированный массив). Например, для массива [1, 2, 3, 4, 5] и искомого элемента 3 результат должен быть 2 (индекс).
Задача 2: Реализуйте бинарный поиск, который возвращает -1, если элемент не найден. Например, для массива [10, 20, 30] и искомого элемента 25 результат должен быть -1.

8. Алгоритм Дейкстры
Задача 1: Реализуйте алгоритм Дейкстры для нахождения кратчайшего пути в графе с положительными весами. Например, для графа с вершинами A, B, C и ребрами с весами, определите 
кратчайший путь от A до C.
Задача 2: Напишите программу, которая, используя алгоритм Дейкстра, находит кратчайшие расстояния от одной вершины до всех остальных в графе.

9. Поиск в ширину
Задача 1: Реализуйте алгоритм поиска в ширину для нахождения кратчайшего пути в графе, представленном в виде списка смежности. Усложните задачу, добавив веса к ребрам и возвращая 
не только путь, но и его стоимость. Например, для графа с вершинами A, B, C, D и ребрами с весами, определите кратчайший путь от A до D и его сумму весов.
Задача 2: Напишите программу, которая находит все вершины, достижимые из заданной вершины в неориентированном графе, но добавьте условие, что некоторые вершины могут быть недоступны 
(например, заблокированы). Например, если граф имеет вершины A, B, C, D и заблокирована вершина C, программа должна вернуть только достижимые вершины от A (например, B и D).

10. Алгоритм K ближайших соседей
Задача 1: Напишите реализацию алгоритма K ближайших соседей для классификации точек в двумерном пространстве. Например, определите класс точки на основании 
ее K ближайших соседей.
Задача 2: Реализуйте KNN для регрессии, где необходимо предсказать значение на основе K ближайших соседей.

11. Деревья
Задача 1: Создайте бинарное дерево поиска и реализуйте функции для вставки узлов. Например, вставьте узлы 5, 3, 7.
Задача 2: Реализуйте алгоритм обхода бинарного дерева (прямой, симметричный и посторочный) и напишите тесты для проверки правильности работы.
